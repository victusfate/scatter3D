<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Scatter3d by victusfate</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="javascripts/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
   
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <script src="javascripts/Three.js"></script><style type="text/css"></style>
    <style type="text/css">
      body {
        margin: 0px;
        padding: 0px;
      }
      #canvas0 {
        position: absolute;
        margin: 0px;
        padding: 0px;
      }
      header {
        float: left;
      }
      #wrapper0 {
        float: left;
      }
    </style>

    <script src="javascripts/raf.js"></script>
  </head>

  <body>
    <div id="canvas0" width='1000px' height='600px'></div>        
    <div id="wrapper0" class="wrapper">
      <header>
        <h1 class="header">Scatter3d</h1>
        <p class="header">webgl 3D scatter plot of decent sized files. includes quick and dirty tab delimited-&gt; json file converter. Original scatter plot source at <a href="http://gdd11-webgl.appspot.com/three/three_8.html">gdd11-webgl</a></p>

        <ul>
          <li class="download"><a class="buttons" href="https://github.com/victusfate/scatter3D/zipball/master">Download ZIP</a></li>
          <li class="download"><a class="buttons" href="https://github.com/victusfate/scatter3D/tarball/master">Download TAR</a></li>
          <li><a class="buttons github" href="https://github.com/victusfate/scatter3D">View On GitHub</a></li>
        </ul>

        <p class="header">This project is maintained by <a class="header name" href="https://github.com/victusfate">victusfate</a></p>


      </header>
      <section>
        <script type='text/javascript' src="dbSkinCovs.dat.json"></script>
        
        <script>
          // <!--
          function createTextCanvas(text, color, font, size) {
            size = size || 24;
            var canvas = document.createElement('canvas');
            var ctx = canvas.getContext('2d');
            var fontStr = (size + 'px ') + (font || 'Arial');
            ctx.font = fontStr;
            var w = ctx.measureText(text).width;
            var h = Math.ceil(size);
            canvas.width = w;
            canvas.height = h;
            ctx.font = fontStr;
            ctx.fillStyle = color || 'black';
            ctx.fillText(text, 0, Math.ceil(size*0.8));
            return canvas;
          }

          function createText2D(text, color, font, size, segW, segH) {
            var canvas = createTextCanvas(text, color, font, size);
            var plane = new THREE.PlaneGeometry(canvas.width, canvas.height, segW, segH);
            var tex = new THREE.Texture(canvas);
            tex.needsUpdate = true;
            var planeMat = new THREE.MeshBasicMaterial({
              map: tex, color: 0xffffff, transparent: true
            });
            var mesh = new THREE.Mesh(plane, planeMat);
            mesh.scale.set(0.25, 0.25, 0.25);
            mesh.doubleSided = true;
            return mesh;
          }

          var renderer = new THREE.WebGLRenderer({antialias: true});
          // var w = document.body.clientWidth || 600;
          // var h = document.body.clientHeight || 600;
          var w = screen.width/1.5;
          var h = screen.height/1.5;
          console.log('client width,height',w,h);
          renderer.setSize(w, h);
          var canvasDiv = document.getElementById('canvas0');
          canvasDiv.appendChild(renderer.domElement);

          renderer.setClearColorHex(0xEEEEEE, 1.0);

          var camera = new THREE.PerspectiveCamera( 45, w/h, 1, 1000 );
          camera.position.z = 200;
          camera.position.x = 600;
          camera.position.y = 400;

          var scene = new THREE.Scene();
          // scene.fog = new THREE.FogExp2( 0xFFFFFF, 0.0035 );

          var scatterPlot = new THREE.Object3D();
          scene.add(scatterPlot);

          scatterPlot.rotation.y = 0.5;
          function v(x,y,z){ return new THREE.Vertex(new THREE.Vector3(x,y,z)); }
          
          var dimMin = 0;
          var dimMax = 255;

          var lineGeo = new THREE.Geometry();
          lineGeo.vertices.push(
            v(dimMin, 0, 0), v(dimMax, 0, 0),
            v(0, dimMin, 0), v(0, dimMax, 0),
            v(0, 0, dimMin), v(0, 0, dimMax),

            v(dimMin, dimMax, dimMin), v(dimMax, dimMax, dimMin),
            v(dimMin, dimMin, dimMin), v(dimMax, dimMin, dimMin),
            v(dimMin, dimMax, dimMax), v(dimMax, dimMax, dimMax),
            v(dimMin, dimMin, dimMax), v(dimMax, dimMin, dimMax),

            v(dimMin, 0, dimMax), v(dimMax, 0, dimMax),
            v(dimMin, 0, dimMin), v(dimMax, 0, dimMin),
            v(dimMin, dimMax, 0), v(dimMax, dimMax, 0),
            v(dimMin, dimMin, 0), v(dimMax, dimMin, 0),

            v(dimMax, dimMin, dimMin), v(dimMax, dimMax, dimMin),
            v(dimMin, dimMin, dimMin), v(dimMin, dimMax, dimMin),
            v(dimMax, dimMin, dimMax), v(dimMax, dimMax, dimMax),
            v(dimMin, dimMin, dimMax), v(dimMin, dimMax, dimMax),

            v(0, dimMin, dimMax), v(0, dimMax, dimMax),
            v(0, dimMin, dimMin), v(0, dimMax, dimMin),
            v(dimMax, dimMin, 0), v(dimMax, dimMax, 0),
            v(dimMin, dimMin, 0), v(dimMin, dimMax, 0),

            v(dimMax, dimMax, dimMin), v(dimMax, dimMax, dimMax),
            v(dimMax, dimMin, dimMin), v(dimMax, dimMin, dimMax),
            v(dimMin, dimMax, dimMin), v(dimMin, dimMax, dimMax),
            v(dimMin, dimMin, dimMin), v(dimMin, dimMin, dimMax),

            v(dimMin, 0, dimMin), v(dimMin, 0, dimMax),
            v(dimMax, 0, dimMin), v(dimMax, 0, dimMax),
            v(0, dimMax, dimMin), v(0, dimMax, dimMax),
            v(0, dimMin, dimMin), v(0, dimMin, dimMax)
          );
          var lineMat = new THREE.LineBasicMaterial({color: 0x808080, lineWidth: 1});
          var line = new THREE.Line(lineGeo, lineMat);
          line.type = THREE.Lines;
          scatterPlot.add(line);

          // var titleX = createText2D('-X');
          // titleX.position.x = -60;
          // scatterPlot.add(titleX);

          var titleX = createText2D('X');
          titleX.position.x = dimMax + 5;
          scatterPlot.add(titleX);

          // var titleX = createText2D('-Y');
          // titleX.position.y = -60;
          // scatterPlot.add(titleX);

          var titleX = createText2D('Y');
          titleX.position.y = dimMax + 5;
          scatterPlot.add(titleX);

          // var titleX = createText2D('-Z');
          // titleX.position.z = -60;
          // scatterPlot.add(titleX);

          var titleX = createText2D('Z');
          titleX.position.z = dimMax + 5;
          scatterPlot.add(titleX);

          var mat = new THREE.ParticleBasicMaterial({vertexColors:true, size: 1.5});

          var randomColor = function() {
            return Math.floor(Math.random()*16777215);
            // return '#' + Math.floor(Math.random()*16777215).toString(16);
          }

          var colors = {};       

          var pointCount = data.length;
          var pointGeo = new THREE.Geometry();
          for (var i=0; i < pointCount; i++) {
            var arr = data[i];
            if (arr) {
              var x = arr[0];
              var y = arr[1];
              var z = arr[2];
              var c = arr[3];
              if (x && y && z && c) {
                pointGeo.vertices.push(new THREE.Vertex( new THREE.Vector3(x,y,z) ));
                var indx = pointGeo.vertices.length - 1;
                pointGeo.vertices[indx].angle = Math.atan2(z,x);
                pointGeo.vertices[indx].radius = Math.sqrt(x*x+z*z);
                pointGeo.vertices[indx].speed = (z/100)*(x/100);
                var pc = randomColor();
                if (colors[c]) {
                  pc = colors[c];
                }
                else {
                    colors[c] = pc;
                }
                pointGeo.colors.push(new THREE.Color(pc));
              }
            }
          }
          var iOffset = 0;        
          var yOffset = -(Object.keys(colors).length * 2.5) - 40;
          console.log('colors after loading all pixels',colors,'yOffset',yOffset);
          for (var iClass in colors) {
            var titleColor1 = createText2D('Class '+iClass,colors[iClass].toString(16));
            titleColor1.position.x = -20;
            titleColor1.position.y = yOffset + 5 * iOffset;
            scatterPlot.add(titleColor1);
            iOffset++;
          }

          var points = new THREE.ParticleSystem(pointGeo, mat);
          scatterPlot.add(points);

          renderer.render(scene, camera);
          var paused = false;
          var last = new Date().getTime();
          var down = false;
          var sx = 0, sy = 0;
          window.onmousedown = function (ev){
            down = true; sx = ev.clientX; sy = ev.clientY;
          };
          window.onmouseup = function(){ down = false; };
          window.onmousemove = function(ev) {
            if (down) {
              var dx = ev.clientX - sx;
              var dy = ev.clientY - sy;
              scatterPlot.rotation.y += dx*0.01;
              camera.position.y += dy;
              sx += dx;
              sy += dy;
            }
          }
          
          function MouseWheelHandler(e) {

            // cross-browser wheel delta
            var e = window.event || e; // old IE support
            var delta = Math.max(-1, Math.min(1, (e.wheelDelta || -e.detail)));
            camera.position.z -= 50 * delta;
          }

          if (window.addEventListener) {
            // IE9, Chrome, Safari, Opera
            window.addEventListener("mousewheel", MouseWheelHandler, false);
            // Firefox
            window.addEventListener("DOMMouseScroll", MouseWheelHandler, false);
          }
          // IE 6/7/8
          else window.attachEvent("onmousewheel", MouseWheelHandler);          


          var animating = false;
          window.ondblclick = function() { animating = !animating; };
          function animate(t) {
            if (!paused) {
              last = t;
              if (animating) {
                var v = pointGeo.vertices;
                for (var i=0; i<v.length; i++) {
                  var u = v[i];
                  u.angle += u.speed * 0.01;
                  u.position.x = Math.cos(u.angle)*u.radius;
                  u.position.z = Math.sin(u.angle)*u.radius;
                }
                pointGeo.__dirtyVertices = true;
              }
              renderer.clear();
              camera.lookAt(scene.position);
              renderer.render(scene, camera);
            }
            window.requestAnimationFrame(animate, renderer.domElement);
          };
          animate(new Date().getTime());
          onmessage = function(ev) {
            paused = (ev.data == 'pause');
          };
          //-->
        </script>
      </section>
    </div>
  </body>
</html>
